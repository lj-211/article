# Error handing
对于所有项目来说，都存在错误处理的问题；本文的描述范围不仅局限于golang本身。
有人调侃golang的代码中有一半都是if err != nil {}，那错误处理更成为golang项目逃不过的话题。

## 规范
上来就列规范，似乎有点不合乎常理，这一堆规范有可能适用或者不适用你，但是我希望你简单浏览后
带着疑问，看我如何解释这些规范。

1. 业务代码中错误统一使用pkg/errors的New/Errorf返回
2. 所有标准库返回的error需要Wrap对上层返回
3. 所有三方库返回的error需要Wrap
4. 业务代码中的API调用产生的error必须处理不可以忽略
5. 不要在common库打印日志，尽量通过堆栈error的形式返回，把错误抛给调用者，而不是自己打日志
6. 在最顶部的调用或者业务最上层输出错误日志，不要每一层调用都输出错误信息
7. 使用errors.Cause来获取最原始的error 例如: io.EOF
8. 不要轻易的在业务代码中调用panic或者Fatal等重量级崩溃函数

## ERROR
### 项目中的错误分类
- 系统API的错误
- 项目基础库的底层错误
- rpc调用错误

假如你是一个项目维护者，那你能遇到的错误无非是上面的三种，可以用更通俗的话来表述，
你调用的系统API出错了，你调用了项目核心基础库出错了，你调用别人的remote api出错了。

### 重新认识错误
> errors are values

[The Go Blog](https://blog.golang.org/errors-are-values)

所有的error都是有价值的，他必须具备以下几个基本信息:
- where 发生在哪
- when 什么时间(当然时间的处理会放在谁来负责处理错误那里说明)
- what 出现了什么错误

所以不要丢弃我们的错误，必须认真检查每一个错误，特别是在多层堆栈调用的情况下，
我们需要将错误逐层上抛，直到有人认领并且处理这个错误。

开发中处理错误可能存在的一些问题:
- 分层开发导致日志打印冗余且无法控制
- 获取不到错误堆栈(非panic)
- 多层返回可能丢失根因

### 明确职责
逐层上抛的错误总要有人来处理，所以我们来看看错误分类是按照什么维度来划分的；
没错，调用方，更准确的说是最上层的业务调用方，由他来负责处理错误，决定业务改怎么继续，是否
需要记录错误（比如打印日志），是否需要发出告警。

我们传递的是错误的信息，但是错误的处理在出栈的过程中，会被业务捕获并且进行错误恢复。

我们来参考一些示例，来看下该如何处理错误。

```
import (
    "github.com/pkg/errors"
)

werr := errors.Wrap(io.EOF, "一层")
w2err := errors.Wrap(werr, "二层")
w3err := errors.Wrap(w2err, "三层")

// 附加堆栈信息
err_stack := errors.WithStack(w3err)

// 使用根因
if errors.Cause(w3err) == io.EOF {
        fmt.Println("io EOF")
}

fmt.Println(w3err.Error())  // 输出信息:  三层: 二层: 一层: EOF
```

> 项目中随处随手打印的日志应该是项目代码中的一个棘手的问题，同样在处理日志的时候，
> 我们也只在错误的处理的位置打印日志，而不是在基础库或者下层逻辑中到处打印日志，
> 这样有利于我们收敛日志，管理日志。

### rpc错误
关于rpc的调用错误，这里要单独拿出来说一下，因为调用两端是远程连接，所有对于错误的设计是有讲究的。

golang的error仅仅是一个interface，那我们改如何去设计一个错误对象，google官方给了我们
一个标准的的参考答案:

- 错误标识处理
- 错误消息展示
- 错误hint数据

```
package google.rpc;

message Status {
    // 一个容易被客户端进行处理的错误码。
    // 实际的错误码在 google.rpc.Code 里面定义
    int32 code = 1;

    // 面向开发人员的可读性高的英文错误信息
    // 这个错误信息应该同时说明错误的原因以及提供一个可操作的处理错误的方法
    string message = 2;

    // 额外的错误信息，这些错误信息可以被客户端代码用来处理这个错误，
    // 例如告诉客户端隔多长时间再次尝试或者提供一个帮助链接
    repeated google.protobuf.Any details = 3;
}
```
